import java.util.ArrayList;
import java.util.Collections;
import java.util.Random;

/**This class creates the necessary methods to build an initial solution with GRASP methodology designed by Feo and Resende.
 *
 */
public class GRASPConstructive implements Constructive {

    private int n;
    private int p;
    private Instance instance;

    private double alpha;
    PointFunction function;

    /** This method made the setup to use GRASP constructive method
     *
     * @param instance The instance of the problem to solve.
     * @param function Function to evaluate each possible median place.
     * @param alpha It controls the greediness of the construction. The balue have to be between 0 and 1, in case of 0 constructive method
     *              is totally random, in case of 1 the constructive method is totally agree.
     */
    public GRASPConstructive(Instance instance, PointFunction function, double alpha) {
        this.n = instance.getN();
        this.p = instance.getP();
        this.instance = instance;
        this.function = function;
        this.alpha = alpha;

    }


    /**This method builds the initial solution for the instance given in the constructor.
     *
     * @return Solution generated by GRASP method
     */
    @Override
    public Solution generateSolution() {
        ArrayList<Par> listaCandidatos = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            listaCandidatos.add(new Par(i, function.f(i)));
        }

        int[] abiertas = new int[p];
        int size = 0;

        Collections.sort(listaCandidatos);

        while(size<p){
            Random r = new Random();
            double cmin = listaCandidatos.get(0).evaluation;
            double cmax = listaCandidatos.get(listaCandidatos.size()-1).evaluation;

            //Cuando alpha=1 es greedy cuando alpha=0 es random
            double cota = cmax + alpha*(cmin-cmax);

            int index = binarySearch(listaCandidatos,cota);

            int elegido = r.nextInt(index+1);

            abiertas[size] = listaCandidatos.remove(elegido).point;
            size++;

        }


        return new Solution(abiertas, instance);


    }

    private  int binarySearch(ArrayList<Par> lista, double cota) {
        int izquierda = 0;
        int derecha = lista.size() - 1;
        int indice = -1;

        while (izquierda <= derecha) {
            int medio = izquierda + (derecha - izquierda) / 2;
            Par elementoMedio = lista.get(medio);

            if (elementoMedio.evaluation < cota) {
                // Actualizamos el Ã­ndice y seguimos buscando a la derecha
                indice = medio;
                izquierda = medio + 1;
            } else {
                // El elemento en medio es mayor o igual a la cota, buscamos a la izquierda
                derecha = medio - 1;
            }
        }

        if(indice == -1) indice = 0;

        return indice;
    }

    private class Par implements Comparable {
        int point;
        int evaluation;

        public Par(int i, int f) {
            point = i;
            evaluation = f;
        }


        @Override
        public int compareTo(Object o) {
            Par i = (Par) o;
            return Integer.compare(this.evaluation, i.evaluation);
        }
    }



}
